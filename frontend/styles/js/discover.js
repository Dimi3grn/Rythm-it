// JavaScript pour la page D√©couverte - discover.js

// JavaScript pour la page D√©couverte - discover.js (VERSION MISE √Ä JOUR)

document.addEventListener('DOMContentLoaded', function() {
    
    // Variables globales
    let currentFilter = 'all';
    let currentCategory = 'all';
    let currentGenre = '';
    let searchTimeout;
    let isVoiceSearchActive = false;
    let selectedTags = [];
    
    // √âl√©ments DOM
    const globalSearch = document.querySelector('.global-search');
    const searchBtn = document.querySelector('.search-btn');
    const voiceSearchBtn = document.querySelector('.voice-search-btn');
    const filterBtns = document.querySelectorAll('.filter-btn');
    const categoryFilters = document.querySelectorAll('.filter-category');
    const genreFilters = document.querySelectorAll('.filter-genre');
    const refreshBtn = document.querySelector('.refresh-recommendations');
    const tagSelector = document.getElementById('tag-selector');
    const selectedTagsContainer = document.getElementById('selected-tags');
    const searchResults = document.getElementById('search-results');
    const discoverSections = document.getElementById('discover-sections');
    
    // Initialisation
    init();
    
    function init() {
        // Attacher les √©v√©nements
        attachEventListeners();
        
        // Animations d'entr√©e
        animateOnLoad();
        
        // D√©marrer les mises √† jour
        startDynamicUpdates();
        
        // Charger le contenu initial
        loadDiscoverContent();
        
        // Initialiser la navigation am√©lior√©e
        if (typeof initializeEnhancedNavigation === 'function') {
            initializeEnhancedNavigation();
        }
        
        // G√©rer les param√®tres URL pour les genres
        handleURLParams();
        
        // Charger les tags depuis l'API
        loadTagsFromAPI();
    }
    
    // NOUVELLE FONCTION: Charger les tags depuis l'API
    function loadTagsFromAPI() {
        fetch('/api/public/tags')
            .then(response => response.json())
            .then(data => {
                console.log('üè∑Ô∏è R√©ponse API tags:', data);
                
                // L'API retourne {success: true, data: [...]}
                const tags = data.success && data.data ? data.data : [];
                
                const tagButtons = document.getElementById('tag-buttons');
                if (tagButtons && tags.length > 0) {
                    tagButtons.innerHTML = '';
                    
                    // Cr√©er une grille de tags
                    const tagGrid = document.createElement('div');
                    tagGrid.className = 'tag-grid';
                    
                    tags.forEach(tag => {
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.className = 'tag-option';
                        button.textContent = tag.name || tag.Name || tag;
                        button.onclick = () => addTag(tag.name || tag.Name || tag);
                        tagGrid.appendChild(button);
                    });
                    
                    tagButtons.appendChild(tagGrid);
                    console.log('üè∑Ô∏è Tags charg√©s depuis l\'API:', tags.length);
                    showNotification(`üè∑Ô∏è ${tags.length} tags charg√©s`, 'success');
                } else {
                    console.warn('‚ö†Ô∏è Aucun tag trouv√© dans la r√©ponse');
                    showNotification('‚ö†Ô∏è Aucun tag disponible', 'warning');
                }
            })
            .catch(error => {
                console.error('‚ùå Erreur lors du chargement des tags:', error);
                showNotification('‚ùå Erreur lors du chargement des tags', 'error');
            });
    }
    
    // NOUVELLE FONCTION: Toggle du s√©lecteur de tags
    window.toggleTagSelector = function() {
        if (!tagSelector) {
            console.error('‚ùå √âl√©ment tag-selector non trouv√©');
            return;
        }
        
        const isVisible = tagSelector.style.display !== 'none';
        
        if (isVisible) {
            tagSelector.style.display = 'none';
            showNotification('üè∑Ô∏è S√©lecteur de tags ferm√©', 'info');
        } else {
            tagSelector.style.display = 'block';
            showNotification('üè∑Ô∏è S√©lecteur de tags ouvert', 'info');
        }
    };
    
    // NOUVELLE FONCTION: Ajouter un tag
    window.addTag = function(tagName) {
        if (!tagName || selectedTags.includes(tagName)) {
            return;
        }
        
        selectedTags.push(tagName);
        updateSelectedTagsDisplay();
        applyTagFilters();
        showNotification(`üè∑Ô∏è Tag "${tagName}" ajout√©`, 'success');
    };
    
    // NOUVELLE FONCTION: Supprimer un tag
    window.removeTag = function(tagName) {
        const index = selectedTags.indexOf(tagName);
        if (index > -1) {
            selectedTags.splice(index, 1);
            updateSelectedTagsDisplay();
            applyTagFilters();
            showNotification(`üè∑Ô∏è Tag "${tagName}" supprim√©`, 'info');
        }
    };
    
    // NOUVELLE FONCTION: Mettre √† jour l'affichage des tags s√©lectionn√©s
    function updateSelectedTagsDisplay() {
        if (!selectedTagsContainer) return;
        
        if (selectedTags.length === 0) {
            selectedTagsContainer.innerHTML = '<p class="no-tags">Aucun tag s√©lectionn√©</p>';
        } else {
            selectedTagsContainer.innerHTML = selectedTags.map(tag => 
                `<span class="selected-tag">
                    ${tag}
                    <button onclick="removeTag('${tag}')" class="remove-tag-btn">√ó</button>
                </span>`
            ).join('');
        }
    }
    
    // NOUVELLE FONCTION: Appliquer les filtres par tags
    function applyTagFilters() {
        if (selectedTags.length === 0) {
            // R√©initialiser l'affichage si aucun tag s√©lectionn√©
            resetSearch();
            return;
        }
        
        // Rechercher automatiquement les threads avec les tags s√©lectionn√©s
        searchThreadsByTags(selectedTags);
    }
    
    // NOUVELLE FONCTION: Rechercher les threads par tags
    async function searchThreadsByTags(tags) {
        try {
            showNotification(`üîç Recherche de threads avec TOUS les tags: ${tags.join(', ')}`, 'info');
            
            // Afficher la section des r√©sultats et masquer les sections de d√©couverte
            if (searchResults) {
                searchResults.style.display = 'block';
                const resultsTitle = document.getElementById('results-title');
                if (resultsTitle) {
                    resultsTitle.textContent = `R√©sultats pour les tags: ${tags.join(' + ')}`;
                }
            }
            
            if (discoverSections) {
                discoverSections.style.display = 'none';
            }
            
            // Afficher le loading
            const searchLoading = document.getElementById('search-loading');
            if (searchLoading) {
                searchLoading.style.display = 'block';
            }
            
            // Construire l'URL avec les tags s√©par√©s par des virgules
            const tagsParam = tags.join(',');
            const url = `/api/public/threads/search?tags=${encodeURIComponent(tagsParam)}`;
            
            console.log('üîç Recherche par tags URL:', url);
            
            const response = await fetch(url);
            const data = await response.json();
            
            console.log('üîç R√©ponse recherche par tags:', data);
            
            // Masquer le loading
            if (searchLoading) {
                searchLoading.style.display = 'none';
            }
            
            if (data.success && data.data && data.data.threads) {
                const threads = data.data.threads;
                displayThreadSearchResults(threads, `Tags: ${tags.join(' + ')}`);
                showNotification(`üè∑Ô∏è ${threads.length} thread(s) trouv√©(s) avec TOUS ces tags`, 'success');
            } else {
                displayNoResults(`Tags: ${tags.join(' + ')}`);
                showNotification('üè∑Ô∏è Aucun thread trouv√© avec TOUS ces tags', 'warning');
            }
        } catch (error) {
            console.error('‚ùå Erreur lors de la recherche par tags:', error);
            
            // Masquer le loading en cas d'erreur
            const searchLoading = document.getElementById('search-loading');
            if (searchLoading) {
                searchLoading.style.display = 'none';
            }
            
            showNotification('‚ùå Erreur lors de la recherche par tags', 'error');
            displayNoResults(`Tags: ${tags.join(' + ')}`);
        }
    }
    
    // NOUVELLE FONCTION: R√©initialiser la recherche
    function resetSearch() {
        if (searchResults) {
            searchResults.style.display = 'none';
        }
        
        if (discoverSections) {
            discoverSections.style.display = 'block';
        }
        
        showNotification('üîÑ Affichage r√©initialis√©', 'info');
    }
    
    // NOUVELLE FONCTION: Effacer la recherche
    window.clearSearch = function() {
        if (globalSearch) {
            globalSearch.value = '';
        }
        
        selectedTags = [];
        updateSelectedTagsDisplay();
        
        resetSearch();
        showNotification('üîç Recherche effac√©e', 'info');
    };
    
    // FONCTION MODIFI√âE: Recherche am√©lior√©e
    window.performSearch = function() {
        const query = globalSearch ? globalSearch.value.trim() : '';
        
        if (query) {
            performSearchWithQuery(query);
        } else if (selectedTags.length > 0) {
            // Recherche par tags seulement
            searchThreadsByTags(selectedTags);
        } else {
            showNotification('üîç Veuillez saisir un terme de recherche ou s√©lectionner des tags', 'warning');
        }
    };
    
    // NOUVELLE FONCTION: G√©rer les param√®tres URL
    function handleURLParams() {
        const urlParams = new URLSearchParams(window.location.search);
        const genreParam = urlParams.get('genre');
        
        if (genreParam) {
            setTimeout(() => {
                setActiveGenre(genreParam);
                showNotification(`üéµ Filtre de genre "${genreParam}" appliqu√©`, 'info');
            }, 1000);
        }
        
        // G√©rer les ancres
        if (window.location.hash) {
            setTimeout(() => {
                handlePageAnchor(window.location.hash);
            }, 1500);
        }
    }
    
    // NOUVELLE FONCTION: G√©rer les ancres de page
    function handlePageAnchor(anchor) {
        switch(anchor) {
            case '#trending':
                scrollToTrending();
                break;
            case '#live-sessions':
                scrollToLiveSessions();
                break;
            default:
                const element = document.querySelector(anchor);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth' });
                }
        }
    }
    
    // NOUVELLE FONCTION: Scroll vers les tendances
    function scrollToTrending() {
        const trendingSection = document.getElementById('trending') || 
                              document.querySelector('.trending-carousel')?.closest('.discover-section');
        
        if (trendingSection) {
            trendingSection.scrollIntoView({ behavior: 'smooth' });
            
            // Mettre en √©vidence temporairement
            trendingSection.style.border = '2px solid rgba(255, 107, 107, 0.5)';
            setTimeout(() => {
                trendingSection.style.border = '';
            }, 3000);
            
            showNotification('üî• Section Tendances mise en √©vidence', 'info');
        }
    }
    
    // NOUVELLE FONCTION: Scroll vers les sessions live
    function scrollToLiveSessions() {
        const liveSection = document.querySelector('.live-sessions') || 
                           document.querySelector('[id*="live"]');
        
        if (liveSection) {
            liveSection.scrollIntoView({ behavior: 'smooth' });
            showNotification('üéµ Sessions Live affich√©es', 'info');
        } else {
            showNotification('üéµ Sessions Live bient√¥t disponibles !', 'info');
        }
    }
    
    // FONCTION MODIFI√âE: Rendre setActiveGenre globale
    window.setActiveGenre = function(genre) {
        // Mettre √† jour la navigation
        document.querySelectorAll('.nav-item[data-genre]').forEach(item => {
            item.classList.remove('active');
            if (item.getAttribute('data-genre') === genre) {
                item.classList.add('active');
            }
        });
        
        currentGenre = genre;
        applyFilters();
        
        // Mettre √† jour l'URL sans recharger la page
        const url = new URL(window.location);
        url.searchParams.set('genre', genre);
        window.history.replaceState({}, '', url);
    };
    
    // Gestion des √©v√©nements (code existant avec modifications)
    function attachEventListeners() {
        // Recherche globale
        if (globalSearch) {
            globalSearch.addEventListener('input', handleSearch);
            globalSearch.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    performSearch();
                }
            });
        }
        
        if (searchBtn) {
            searchBtn.addEventListener('click', performSearch);
        }
        
        if (voiceSearchBtn) {
            voiceSearchBtn.addEventListener('click', toggleVoiceSearch);
        }
        
        // Filtres principaux
        filterBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                const filter = this.getAttribute('data-filter');
                setActiveFilter(filter);
            });
        });
        
        // MODIFI√â: Filtres de genres avec gestion URL
        document.querySelectorAll('.nav-item[data-genre]').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
                const genre = this.getAttribute('data-genre');
                setActiveGenre(genre);
                showNotification(`üéµ Filtre ${genre} appliqu√©`, 'info');
            });
        });
        
        // Filtres de cat√©gories
        categoryFilters.forEach(filter => {
            filter.addEventListener('click', function(e) {
                e.preventDefault();
                const category = this.getAttribute('data-category');
                setActiveCategory(category);
            });
        });
        
        // Boutons de lecture
        document.querySelectorAll('.play-btn-large, .play-btn-medium, .play-rec-btn').forEach(btn => {
            btn.addEventListener('click', handlePlay);
        });
        
        // Actions des artistes
        document.querySelectorAll('.follow-btn').forEach(btn => {
            btn.addEventListener('click', handleFollow);
        });
        
        document.querySelectorAll('.play-artist-btn').forEach(btn => {
            btn.addEventListener('click', handlePlayArtist);
        });
        
        // Actions des playlists
        document.querySelectorAll('.like-playlist-btn').forEach(btn => {
            btn.addEventListener('click', handleLikePlaylist);
        });
        
        document.querySelectorAll('.save-playlist-btn').forEach(btn => {
            btn.addEventListener('click', handleSavePlaylist);
        });
        
        document.querySelectorAll('.share-playlist-btn').forEach(btn => {
            btn.addEventListener('click', handleSharePlaylist);
        });
        
        // Boutons d'exploration
        document.querySelectorAll('.explore-rec-btn').forEach(btn => {
            btn.addEventListener('click', handleExploreRecommendation);
        });
        
        // Actualisation des recommandations
        if (refreshBtn) {
            refreshBtn.addEventListener('click', refreshRecommendations);
        }
        
        // Actions de la sidebar
        const discoverGenreBtn = document.querySelector('.discover-genre-btn');
        if (discoverGenreBtn) {
            discoverGenreBtn.addEventListener('click', exploreGenre);
        }
        
        // Sessions live
        document.querySelectorAll('.join-live-btn').forEach(btn => {
            btn.addEventListener('click', joinLiveSession);
        });
        
        document.querySelectorAll('.notify-live-btn').forEach(btn => {
            btn.addEventListener('click', notifyLiveSession);
        });
        
        // Navigation hover effects
        document.querySelectorAll('.trending-item, .artist-card, .album-card, .playlist-discover-card').forEach(card => {
            card.addEventListener('mouseenter', handleCardHover);
            card.addEventListener('mouseleave', handleCardLeave);
        });
    }
    
    // [RESTE DU CODE EXISTANT - toutes les autres fonctions restent identiques]
    // Gestion de la recherche
    function handleSearch() {
        const query = globalSearch.value;
        
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
            if (query.length > 2) {
                performSearchWithQuery(query);
            } else if (query.length === 0) {
                resetSearch();
            }
        }, 300);
    }
    
    function performSearch() {
        const query = globalSearch ? globalSearch.value.trim() : '';
        
        if (query) {
            performSearchWithQuery(query);
        } else if (selectedTags.length > 0) {
            // Recherche par tags seulement
            searchThreadsByTags(selectedTags);
        } else {
            showNotification('üîç Veuillez saisir un terme de recherche ou s√©lectionner des tags', 'warning');
        }
    }
    
    function performSearchWithQuery(query) {
        showNotification(`üîç Recherche: "${query}"`, 'info');
        
        // Afficher la section des r√©sultats et masquer les sections de d√©couverte
        if (searchResults) {
            searchResults.style.display = 'block';
            const resultsTitle = document.getElementById('results-title');
            if (resultsTitle) {
                resultsTitle.textContent = `R√©sultats pour "${query}"`;
            }
        }
        
        if (discoverSections) {
            discoverSections.style.display = 'none';
        }
        
        // Afficher le loading
        const searchLoading = document.getElementById('search-loading');
        if (searchLoading) {
            searchLoading.style.display = 'block';
        }
        
        // Effectuer la recherche r√©elle dans les threads via l'API
        searchThreadsInDatabase(query)
            .then(results => {
                if (searchLoading) {
                    searchLoading.style.display = 'none';
                }
                
                // Construire le message de recherche
                let searchMessage = `"${query}"`;
                if (selectedTags.length > 0) {
                    searchMessage += ` + tags: ${selectedTags.join(' + ')}`;
                }
                
                displayThreadSearchResults(results, searchMessage);
                
                if (selectedTags.length > 0) {
                    showNotification(`‚úÖ ${results.length} thread(s) trouv√©(s) avec le texte ET tous les tags`, 'success');
                } else {
                    showNotification(`‚úÖ ${results.length} thread(s) trouv√©(s)`, 'success');
                }
            })
            .catch(error => {
                console.error('‚ùå Erreur lors de la recherche:', error);
                if (searchLoading) {
                    searchLoading.style.display = 'none';
                }
                showNotification('‚ùå Erreur lors de la recherche', 'error');
                displayNoResults(query);
            });
    }
    
    // NOUVELLE FONCTION: Rechercher les threads dans la base de donn√©es
    async function searchThreadsInDatabase(query) {
        try {
            // Construire l'URL de recherche avec les param√®tres
            const searchParams = new URLSearchParams();
            searchParams.append('q', query);
            
            // Ajouter les tags s√©lectionn√©s
            if (selectedTags.length > 0) {
                searchParams.append('tags', selectedTags.join(','));
            }
            
            const response = await fetch(`/api/public/threads/search?${searchParams.toString()}`);
            
            if (!response.ok) {
                throw new Error(`Erreur HTTP: ${response.status}`);
            }
            
            const data = await response.json();
            console.log('üîç R√©sultats de recherche re√ßus:', data);
            
            // L'API retourne {success: true, data: {threads: [...], count: ...}}
            if (data.success && data.data && data.data.threads) {
                return data.data.threads;
            }
            
            return [];
        } catch (error) {
            console.error('‚ùå Erreur lors de la recherche de threads:', error);
            throw error;
        }
    }
    
    // NOUVELLE FONCTION: Afficher les r√©sultats de recherche de threads
    function displayThreadSearchResults(threads, query) {
        const resultsList = document.getElementById('results-list');
        if (!resultsList) return;
        
        if (threads.length === 0) {
            displayNoResults(query);
            return;
        }
        
        let html = `
            <div class="results-section">
                <h3>üßµ Discussions trouv√©es (${threads.length})</h3>
                <div class="results-grid thread-results">
        `;
        
        threads.forEach(thread => {
            html += createThreadResultHTML(thread);
        });
        
        html += `
                </div>
            </div>
        `;
        
        resultsList.innerHTML = html;
        
        // R√©attacher les √©v√©nements aux nouveaux √©l√©ments
        reattachThreadEventListeners();
    }
    
    // NOUVELLE FONCTION: Cr√©er le HTML pour un thread dans les r√©sultats
    function createThreadResultHTML(thread) {
        const timeAgo = formatTimeAgo(thread.created_at || thread.CreatedAt);
        const likes = thread.likes || thread.Likes || 0;
        const comments = thread.comments || thread.Comments || 0;
        const author = thread.author || thread.Author || 'Utilisateur';
        const title = thread.title || thread.Title || 'Sans titre';
        const content = thread.content || thread.Content || '';
        const threadId = thread.id || thread.ID;
        
        // Extraire les tags si disponibles
        let tagsHTML = '';
        if (thread.tags && Array.isArray(thread.tags)) {
            tagsHTML = thread.tags.map(tag => `<span class="tag">${tag}</span>`).join('');
        }
        
        return `
            <div class="thread-result-item" data-thread-id="${threadId}">
                <div class="thread-result-header">
                    <div class="user-pic">${author.substring(0, 2).toUpperCase()}</div>
                    <div class="thread-result-meta">
                        <h4>${author}</h4>
                        <span class="thread-result-time">${timeAgo}</span>
                    </div>
                </div>
                <div class="thread-result-content">
                    <h3 class="thread-result-title">${title}</h3>
                    <p class="thread-result-text">${content.substring(0, 150)}${content.length > 150 ? '...' : ''}</p>
                    ${tagsHTML ? `<div class="thread-result-tags">${tagsHTML}</div>` : ''}
                </div>
                <div class="thread-result-stats">
                    <span class="stat">‚ù§Ô∏è ${likes}</span>
                    <span class="stat">üí¨ ${comments}</span>
                    <a href="/thread/${threadId}" class="view-thread-btn">Voir le thread ‚Üí</a>
                </div>
            </div>
        `;
    }
    
    // NOUVELLE FONCTION: Afficher "aucun r√©sultat"
    function displayNoResults(query) {
        const resultsList = document.getElementById('results-list');
        if (!resultsList) return;
        
        resultsList.innerHTML = `
            <div class="no-results">
                <h3>Aucun thread trouv√©</h3>
                <p>Aucun thread ne correspond √† votre recherche "${query}".</p>
                <div class="search-suggestions">
                    <h4>Suggestions :</h4>
                    <ul>
                        <li>V√©rifiez l'orthographe de vos mots-cl√©s</li>
                        <li>Essayez des termes plus g√©n√©raux</li>
                        <li>Utilisez les filtres par tags</li>
                        <li>Recherchez par nom d'artiste ou genre musical</li>
                    </ul>
                </div>
            </div>
        `;
    }
    
    // NOUVELLE FONCTION: Formater le temps relatif
    function formatTimeAgo(dateString) {
        if (!dateString) return 'R√©cemment';
        
        const date = new Date(dateString);
        const now = new Date();
        const diffInSeconds = Math.floor((now - date) / 1000);
        
        if (diffInSeconds < 60) return '√Ä l\'instant';
        if (diffInSeconds < 3600) return `il y a ${Math.floor(diffInSeconds / 60)}min`;
        if (diffInSeconds < 86400) return `il y a ${Math.floor(diffInSeconds / 3600)}h`;
        if (diffInSeconds < 2592000) return `il y a ${Math.floor(diffInSeconds / 86400)}j`;
        
        return date.toLocaleDateString('fr-FR');
    }
    
    // NOUVELLE FONCTION: R√©attacher les √©v√©nements pour les threads
    function reattachThreadEventListeners() {
        // G√©rer les clics sur les threads pour navigation
        document.querySelectorAll('.thread-result-item').forEach(item => {
            item.addEventListener('click', function(e) {
                // Ne pas naviguer si on clique sur le bouton "Voir le thread"
                if (e.target.classList.contains('view-thread-btn')) {
                    return;
                }
                
                const threadId = this.getAttribute('data-thread-id');
                if (threadId) {
                    window.location.href = `/thread/${threadId}`;
                }
            });
        });
        
        // G√©rer les boutons "Voir le thread"
        document.querySelectorAll('.view-thread-btn').forEach(btn => {
            btn.addEventListener('click', function(e) {
                e.stopPropagation();
                // La navigation se fait via le href
            });
        });
    }
    
    // Recherche vocale
    function toggleVoiceSearch() {
        if (!isVoiceSearchActive) {
            startVoiceSearch();
        } else {
            stopVoiceSearch();
        }
    }
    
    function startVoiceSearch() {
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const recognition = new SpeechRecognition();
            
            recognition.lang = 'fr-FR';
            recognition.continuous = false;
            recognition.interimResults = false;
            
            recognition.onstart = function() {
                isVoiceSearchActive = true;
                voiceSearchBtn.style.color = '#ff6b6b';
                voiceSearchBtn.style.animation = 'pulse 1s infinite';
                globalSearch.placeholder = 'Parlez maintenant...';
                showNotification('üé§ √âcoute en cours...', 'info');
            };
            
            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                globalSearch.value = transcript;
                performSearchWithQuery(transcript);
                showNotification(`üé§ Recherche vocale: "${transcript}"`, 'success');
            };
            
            recognition.onerror = function(event) {
                showNotification('‚ùå Erreur de reconnaissance vocale', 'warning');
            };
            
            recognition.onend = function() {
                stopVoiceSearch();
            };
            
            recognition.start();
        } else {
            showNotification('‚ùå Recherche vocale non support√©e', 'warning');
        }
    }
    
    function stopVoiceSearch() {
        isVoiceSearchActive = false;
        voiceSearchBtn.style.color = '';
        voiceSearchBtn.style.animation = '';
        globalSearch.placeholder = 'Rechercher des artistes, albums, playlists...';
    }
    
    // Gestion des filtres
    function setActiveFilter(filter) {
        // Mettre √† jour les boutons
        filterBtns.forEach(btn => btn.classList.remove('active'));
        document.querySelector(`[data-filter="${filter}"]`).classList.add('active');
        
        currentFilter = filter;
        applyFilters();
    }
    
    function setActiveCategory(category) {
        // Mettre √† jour la navigation
        categoryFilters.forEach(filter => filter.classList.remove('active'));
        document.querySelector(`[data-category="${category}"]`).classList.add('active');
        
        currentCategory = category;
        applyFilters();
    }
    
    function applyFilters() {
        // Filtrer les √©l√©ments visibles
        const allItems = document.querySelectorAll('.artist-card, .album-card, .playlist-discover-card');
        
        allItems.forEach(item => {
            let shouldShow = true;
            
            // Filtre par cat√©gorie
            if (currentCategory !== 'all') {
                const itemCategory = item.getAttribute('data-category');
                if (itemCategory && itemCategory !== currentCategory) {
                    shouldShow = false;
                }
            }
            
            // Filtre par genre
            if (currentGenre && currentGenre !== '') {
                const itemGenre = item.getAttribute('data-genre');
                if (itemGenre && itemGenre !== currentGenre) {
                    shouldShow = false;
                }
            }
            
            // Appliquer la visibilit√©
            if (shouldShow) {
                item.style.display = 'block';
                setTimeout(() => {
                    item.style.opacity = '1';
                    item.style.transform = 'translateY(0)';
                }, 50);
            } else {
                item.style.opacity = '0';
                item.style.transform = 'translateY(20px)';
                setTimeout(() => {
                    item.style.display = 'none';
                }, 300);
            }
        });
        
        showNotification(`Filtres appliqu√©s: ${currentCategory} ${currentGenre ? '‚Ä¢ ' + currentGenre : ''}`, 'info');
    }
    
    // [TOUTES LES AUTRES FONCTIONS RESTENT IDENTIQUES]
    // Actions de lecture, artistes, playlists, etc... (code existant)
    
    // Actions de lecture
    function handlePlay(e) {
        const btn = e.currentTarget;
        const card = btn.closest('.trending-item, .album-card, .rec-track');
        
        // Animation de lecture
        btn.style.transform = 'scale(0.9)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        // Changer l'√©tat
        const isPlaying = btn.textContent.includes('‚è∏Ô∏è');
        btn.textContent = isPlaying ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
        
        // Notification
        if (card) {
            const title = card.querySelector('h3, h4, h5')?.textContent || 'Piste';
            if (!isPlaying) {
                showNotification(`üéµ Lecture: ${title}`, 'music');
                animatePlayingCard(card);
            } else {
                showNotification('‚è∏Ô∏è Lecture en pause', 'info');
            }
        }
    }
    
    function animatePlayingCard(card) {
        card.style.border = '2px solid rgba(102, 126, 234, 0.5)';
        card.style.boxShadow = '0 0 30px rgba(102, 126, 234, 0.3)';
        
        // Ajouter une animation de pulsation
        card.style.animation = 'gentle-pulse 2s ease-in-out infinite';
    }
    
    // Actions des artistes
    function handleFollow(e) {
        const btn = e.currentTarget;
        const artistCard = btn.closest('.artist-card');
        const artistName = artistCard.querySelector('h4').textContent;
        
        // Animation
        btn.style.transform = 'scale(0.95)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        // Changer l'√©tat
        const isFollowing = btn.textContent.includes('Suivi');
        if (isFollowing) {
            btn.textContent = '+ Suivre';
            btn.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            showNotification(`‚ùå Vous ne suivez plus ${artistName}`, 'info');
        } else {
            btn.textContent = '‚úì Suivi';
            btn.style.background = 'linear-gradient(135deg, #4ade80 0%, #22c55e 100%)';
            showNotification(`‚úÖ Vous suivez maintenant ${artistName}`, 'success');
        }
    }
    
    function handlePlayArtist(e) {
        const btn = e.currentTarget;
        const artistCard = btn.closest('.artist-card');
        const artistName = artistCard.querySelector('h4').textContent;
        
        btn.style.transform = 'scale(0.9)';
        setTimeout(() => {
            btn.style.transform = 'scale(1.1)';
        }, 150);
        
        showNotification(`üéµ Lecture de ${artistName}`, 'music');
    }
    
    // Actions des playlists
    function handleLikePlaylist(e) {
        const btn = e.currentTarget;
        const isLiked = btn.style.color === 'rgb(255, 107, 107)';
        
        btn.style.transform = 'scale(1.2)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 200);
        
        if (isLiked) {
            btn.style.color = '';
            showNotification('üíî Like retir√©', 'info');
        } else {
            btn.style.color = '#ff6b6b';
            showNotification('‚ù§Ô∏è Playlist lik√©e !', 'success');
        }
    }
    
    function handleSavePlaylist(e) {
        const btn = e.currentTarget;
        const playlistCard = btn.closest('.playlist-discover-card');
        const playlistName = playlistCard.querySelector('h4').textContent;
        
        btn.style.transform = 'scale(1.2)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 200);
        
        btn.style.color = '#4ade80';
        showNotification(`üíæ "${playlistName}" sauvegard√©e !`, 'success');
    }
    
    function handleSharePlaylist(e) {
        const btn = e.currentTarget;
        const playlistCard = btn.closest('.playlist-discover-card');
        const playlistName = playlistCard.querySelector('h4').textContent;
        
        btn.style.transform = 'scale(1.2)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 200);
        
        // Simuler le partage
        if (navigator.share) {
            navigator.share({
                title: playlistName,
                text: `D√©couvrez cette playlist sur Rythm'it !`,
                url: window.location.href
            });
        } else {
            // Fallback
            navigator.clipboard.writeText(window.location.href);
            showNotification('üîó Lien copi√© dans le presse-papier !', 'success');
        }
    }
    
    // Exploration des recommandations
    function handleExploreRecommendation(e) {
        const btn = e.currentTarget;
        
        btn.style.transform = 'scale(0.98)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        showNotification('üéØ Chargement des recommandations...', 'info');
        
        // Simuler le chargement
        setTimeout(() => {
            showNotification('‚ú® Nouvelles recommandations charg√©es !', 'success');
        }, 1500);
    }
    
    // Actualisation des recommandations
    function refreshRecommendations() {
        refreshBtn.style.transform = 'rotate(360deg)';
        refreshBtn.style.transition = 'transform 0.8s ease';
        
        showNotification('üîÑ Actualisation des recommandations...', 'info');
        
        setTimeout(() => {
            refreshBtn.style.transform = 'rotate(0deg)';
            generateNewRecommendations();
            showNotification('‚úÖ Recommandations actualis√©es !', 'success');
        }, 800);
    }
    
    function generateNewRecommendations() {
        const recCards = document.querySelectorAll('.recommendation-card');
        recCards.forEach(card => {
            // Animer le changement
            card.style.opacity = '0.5';
            setTimeout(() => {
                // Simuler de nouvelles donn√©es
                const confidence = card.querySelector('.rec-confidence');
                if (confidence) {
                    const newPercentage = Math.floor(Math.random() * 20) + 80;
                    confidence.textContent = `${newPercentage}% de correspondance`;
                }
                card.style.opacity = '1';
            }, 400);
        });
    }
    
    // Exploration de genre
    function exploreGenre() {
        const btn = document.querySelector('.discover-genre-btn');
        btn.style.transform = 'scale(0.95)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        showNotification('üöÄ Exploration du genre Synthwave...', 'music');
        
        // Mettre en √©vidence les √©l√©ments Synthwave
        setTimeout(() => {
            highlightGenreElements('electronic');
            showNotification('‚ú® Contenu Synthwave mis en √©vidence !', 'success');
        }, 1000);
    }
    
    function highlightGenreElements(genre) {
        const genreItems = document.querySelectorAll(`[data-genre="${genre}"]`);
        genreItems.forEach(item => {
            item.style.border = '2px solid rgba(255, 107, 107, 0.5)';
            item.style.transform = 'scale(1.02)';
            
            setTimeout(() => {
                item.style.border = '';
                item.style.transform = '';
            }, 3000);
        });
    }
    
    // Sessions live
    function joinLiveSession(e) {
        const btn = e.currentTarget;
        const session = btn.closest('.live-session');
        const sessionName = session.querySelector('h5').textContent;
        
        btn.style.transform = 'scale(0.95)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        btn.textContent = 'üî¥ En session';
        btn.style.background = 'linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%)';
        
        showNotification(`üéß Vous avez rejoint "${sessionName}"`, 'success');
    }
    
    function notifyLiveSession(e) {
        const btn = e.currentTarget;
        
        btn.style.transform = 'scale(0.95)';
        setTimeout(() => {
            btn.style.transform = 'scale(1)';
        }, 150);
        
        btn.textContent = 'üîî Notifi√©';
        showNotification('üîî Vous serez notifi√© du d√©but de la session', 'info');
    }
    
    // Effets de hover sur les cartes
    function handleCardHover(e) {
        const card = e.currentTarget;
        card.style.transition = 'all 0.3s ease';
        
        // Ajouter un effet de lueur subtile
        if (card.classList.contains('trending-item')) {
            card.style.boxShadow = '0 20px 50px rgba(102, 126, 234, 0.2)';
        } else {
            card.style.boxShadow = '0 15px 35px rgba(0, 0, 0, 0.3)';
        }
    }
    
    function handleCardLeave(e) {
        const card = e.currentTarget;
        card.style.boxShadow = '';
    }
    
    // Animations au chargement
    function animateOnLoad() {
        // Animer les sections une par une
        const sections = document.querySelectorAll('.discover-section');
        sections.forEach((section, index) => {
            section.style.opacity = '0';
            section.style.transform = 'translateY(30px)';
            
            setTimeout(() => {
                section.style.transition = 'opacity 0.8s ease, transform 0.8s ease';
                section.style.opacity = '1';
                section.style.transform = 'translateY(0)';
            }, 200 + index * 300);
        });
        
        // Animer les cartes dans chaque section
        setTimeout(() => {
            animateCards();
        }, 1000);
    }
    
    function animateCards() {
        const cards = document.querySelectorAll('.trending-item, .artist-card, .album-card, .playlist-discover-card');
        cards.forEach((card, index) => {
            card.style.opacity = '0';
            card.style.transform = 'translateY(20px)';
            
            setTimeout(() => {
                card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                card.style.opacity = '1';
                card.style.transform = 'translateY(0)';
            }, index * 100);
        });
    }
    
    // Chargement du contenu initial
    function loadDiscoverContent() {
        showNotification('üîç Chargement du contenu de d√©couverte...', 'info');
        
        setTimeout(() => {
            showNotification('‚úÖ Contenu charg√© avec succ√®s !', 'success');
        }, 1500);
    }
    
    // Mises √† jour dynamiques
    function startDynamicUpdates() {
        // Mettre √† jour les statistiques des tendances
        setInterval(updateTrendingStats, 10000);
        
        // Simuler de nouveaux contenus
        setInterval(addNewContent, 30000);
        
        // Mettre √† jour les sessions live
        setInterval(updateLiveSessions, 20000);
    }
    
    function updateTrendingStats() {
        const trendingStats = document.querySelectorAll('.trending-stats span');
        trendingStats.forEach(stat => {
            if (stat.textContent.includes('√©coutes')) {
                const currentCount = parseInt(stat.textContent.match(/[\d.]+/)[0] * 1000000);
                const newCount = currentCount + Math.floor(Math.random() * 10000);
                const formattedCount = (newCount / 1000000).toFixed(1);
                stat.textContent = stat.textContent.replace(/[\d.]+/, formattedCount);
            }
        });
    }
    
    function addNewContent() {
        // Simuler l'ajout de nouveau contenu
        if (Math.random() < 0.3) {
            showNotification('‚ú® Nouveau contenu disponible !', 'info');
        }
    }
    
    function updateLiveSessions() {
        const liveSessions = document.querySelectorAll('.live-session');
        liveSessions.forEach(session => {
            const listener = session.querySelector('.session-info p');
            if (listener && listener.textContent.includes('auditeurs')) {
                const currentCount = parseInt(listener.textContent.match(/\d+/)[0]);
                const newCount = currentCount + Math.floor(Math.random() * 20) - 10;
                listener.textContent = `${Math.max(newCount, 0)} auditeurs`;
            }
        });
    }
    
    // Fonction de notification
    function showNotification(message, type = 'info') {
        if (typeof window.showNotification === 'function') {
            window.showNotification(message, type);
        } else {
            console.log(`Notification: ${message}`);
        }
    }
    
    // Raccourcis clavier
    document.addEventListener('keydown', function(e) {
        // Ctrl + F pour focus sur la recherche
        if (e.ctrlKey && e.key === 'f') {
            e.preventDefault();
            globalSearch.focus();
        }
        
        // Espace pour pause/play si focus sur une carte
        if (e.key === ' ' && document.activeElement.classList.contains('play-btn-large')) {
            e.preventDefault();
            document.activeElement.click();
        }
        
        // Fl√®ches pour naviguer entre les cartes
        if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
            const focusedCard = document.querySelector('.trending-item:focus, .artist-card:focus, .album-card:focus');
            if (focusedCard) {
                const allCards = Array.from(document.querySelectorAll('.trending-item, .artist-card, .album-card'));
                const currentIndex = allCards.indexOf(focusedCard);
                const nextIndex = e.key === 'ArrowRight' ? 
                    (currentIndex + 1) % allCards.length : 
                    (currentIndex - 1 + allCards.length) % allCards.length;
                allCards[nextIndex].focus();
            }
        }
    });
    
    // Rendre les cartes focusables
    document.querySelectorAll('.trending-item, .artist-card, .album-card, .playlist-discover-card').forEach(card => {
        card.setAttribute('tabindex', '0');
    });
    
    console.log('üîç Page D√©couverte Rythm\'it initialis√©e avec succ√®s !');
    console.log('üéµ Fonctionnalit√©s: Recherche avanc√©e, Filtres dynamiques, Navigation am√©lior√©e');
});

// Fonctions pour la navigation dans la sidebar
function scrollToSection(sectionId) {
    const section = document.getElementById(sectionId);
    if (section) {
        section.scrollIntoView({ 
            behavior: 'smooth',
            block: 'start'
        });
        showNotification(`üìç Navigation vers ${sectionId}`, 'info');
    }
}

function filterByGenre(genre) {
    // Activer le filtre de genre
    const filterBtns = document.querySelectorAll('.filter-btn');
    filterBtns.forEach(btn => btn.classList.remove('active'));
    
    // Chercher s'il y a un bouton de filtre pour ce genre
    const genreBtn = Array.from(filterBtns).find(btn => 
        btn.textContent.toLowerCase().includes(genre.toLowerCase())
    );
    
    if (genreBtn) {
        genreBtn.classList.add('active');
    }
    
    // Filtrer les √©l√©ments par genre
    const allItems = document.querySelectorAll('.trending-item, .artist-card, .album-card, .playlist-discover-card');
    allItems.forEach(item => {
        const itemGenre = item.getAttribute('data-genre');
        if (!itemGenre || itemGenre.toLowerCase().includes(genre.toLowerCase())) {
            item.style.display = 'block';
            item.style.opacity = '1';
        } else {
            item.style.opacity = '0.3';
        }
    });
    
    showNotification(`üéµ Filtr√© par genre: ${genre}`, 'success');
    
    // Scroll vers la section des r√©sultats
    setTimeout(() => {
        const firstSection = document.querySelector('.discover-section');
        if (firstSection) {
            firstSection.scrollIntoView({ 
                behavior: 'smooth',
                block: 'start'
            });
        }
    }, 300);
}

// Export pour utilisation dans d'autres scripts
window.initializeEnhancedNavigation = initializeEnhancedNavigation;
window.handleInternalAnchor = handleInternalAnchor;
window.updateActiveNavigation = updateActiveNavigation;
window.scrollToSection = scrollToSection;
window.filterByGenre = filterByGenre;